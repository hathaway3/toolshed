<HTML>
<HEAD>
	<TITLE>Appendix C - Relocatable Object File Format</TITLE>
	<LINK href="styles.css" type=text/css rel=stylesheet >
</HEAD>
<style type=text/css>

table {
	font-size : 10pt;
	color : #000000;
	font-family: Arial, Verdana, Helvetica, sans-serif;
	border: 1px #000000 solid;
	border-collapse: collapse; 
}

td {
	vertical-align: top;
	white-space: normal;
	font-size : 10pt;
	color : #000000;
	border: 1px #c0c0c0 solid;
	font-family: Arial, Verdana, Helvetica, sans-serif;
	padding: 2px 5px 2px 5px;
	text-align: left;
}


td.rinfo {
	vertical-align: top;
	white-space: normal;
	font-size : 10pt;
	color : #000000;
	border: 1px #c0c0c0 solid;
	font-family: Arial, Verdana, Helvetica, sans-serif;
	padding: 2px 5px 2px 5px;
	text-align: center;
}


td.rheader {
	color: #000000;
	background-color: #eeeeee;
	font-family: Arial, Verdana, Helvetica, sans-serif;
	font-size: 10pt;
	font-weight: bold;
	padding: 2px 5px 2px 5px;
	text-align: center;
	vertical-align: bottom;
}

</style>

<body class=site>
<div class="title">
	<b>Appendix C - Relocatable Object File Format</b><br>
	From <em>unknown source (OS-9 Level II Dev Manual??)</em>
</div>
<div class="main">
<table class="info" width="550" style="border: 0px #000000 solid;" ID="Table1">
	<tr><td style="border: 0px; white-space: normal; text-align: left;">
		<center><h3>Appendix C - Relocatable Object File Format</h2></center>
		<br>			
		The object code generated by the C assembler must be processed by the
		linker before the code is executable. The C assembler writes the
		object code in a special relocatable object file format (ROF) to
		allow the linker to link together separately assembled modules into
		a single executable module. The ROF contains information such as
		global data definitions, code entry point, external references, object
		code, initialized and un-initialized data.<br>
		<br>
		It is unlikely that a programmer would have to deal with the internal
		of an ROF. The information given here is for informational purposes.<br>
		<br>
		The rdump program can be used to display ROF data from an existing
		relocatable files.<br>
		<br>
		<table align="center" width="500" class="info" ID="Table2">
			<tr><td class="rheader" colspan="4">ROF Header Section</td></tr>
			<tr>				<td class="rheader">Offset</td>				<td class="rheader">Bytest</td>				<td class="rheader">Description</td>				<td class="rheader">Description</td>			</tr>						<tr>				<td>$0000</td>				<td>4</td>				<td>Sync Bytes</td>				<td>Rlink uses the sync bytes to reconize the ROF.</td>			</tr>						<tr>				<td>$0004</td>				<td>2</td>				<td>Type/Language.</td>				<td>
					The type/language bytes from the psect. The bytes are used by the
					linker to determine the desired OS-9 module format. Only a mainline
					segment can have these bytes non-zero.
				</td>
			</tr>						<tr>				<td>$0006</td>				<td>1</td>				<td>Assembly Valid</td>				<td>					The assembly valid byte will be non-zero if errors occured during assembly.					Prevents the linker from linking to an erroreous module				</td>			</tr>						<tr>				<td>$0007</td>				<td>5</td>				<td>Date/Time</td>				<td>Indicates date and time of assembly.</td>			</tr>						<tr>				<td>$000C</td>				<td>1</td>				<td>Edition Number</td>				<td>					The OS-9 edition number placed in the output module for mainline segments.					For non-mainline segments the edition number provides module information only.				</td>			</tr>						<tr>				<td>$000D</td>				<td>1</td>				<td>Version</td>				<td>
					Indicates to the linker the assembler version number. Used to pevent problems
					that could occur when mixing different versions of the assembler and linker.
					For this byte rma generates $01 while c.asm generates $00.
				</td>
			</tr>						<tr>				<td>$000E</td>				<td>2</td>				<td>BSS Data Size</td>				<td>					The linker reserves static data storage for the module.					The linker determines the static storage requirements from					the total size of the vsect rmb statements in the psects.				</td>			</tr>						<tr>				<td>$0010</td>				<td>2</td>				<td>Direct Page BSS Size</td>				<td>
					RLink determines the uninitialized Direct Page requirements from
					the modules vsect dp declaration using the rmb statement.
				</td>
			</tr>						<tr>				<td>$0012</td>				<td>2</td>				<td>Initialized Data Size</td>				<td>					Tells the linker the size of initialized data the module contains.					The size is determined by the total size of the fcb, fdb, and fcc					statements in the vsects declaration.				</td>			</tr>						<tr>				<td>$0014</td>				<td>2</td>				<td>Initialized Direct Page Data Size</td>				<td>					RLink determines the Direct Page requirements from the					modules vsect DP statement.				</td>			</tr>						<tr>				<td>$0016</td>				<td>2</td>				<td>Module Code Size</td>				<td>Executable code size after linkage.</td>			</tr>						<tr>				<td>$0018</td>				<td>2</td>				<td>Module Stack Size</td>				<td>
					The stack size word tells the linker the stack space required by the module.
					The linler takes the value directly from the psect.
				</td>
			</tr>						<tr>				<td>$001A</td>				<td>2</td>				<td>Module Entry Point</td>				<td>
					The offset to the entry point in the assembled object code.
					The offset is relative to the beginning of the module.
					The linker obtains the value directly from the psect.
				</td>
			</tr>						<tr>				<td>$001C</td>				<td>?</td>				<td>Module Name</td>				<td>					The NULL terminated module name string taken directly					from the psect directive. The linker uses the name to					identify the psect in case of an unresolved reference					or other error.				</td>			</tr>				</table>	<br>	<br><table class="code" align="center" width="500" ID="Table5"><tr><td class="code">
<pre>
	psect	name_a,0,0,0,0,0

* The ROF Header:

$0000	fdb	$62cd,$2387	Sync bytes
$0004	fdb	$0000		Type/Language
$0006	fcb	$00		Valid Assembly
$0007	fcb	$56		Creation date (5 bytes)
$0008	fcb	$09
$0009	fcb	$09
$000A	fcb	$0d
$000B	fcb	$23
$000C	fcb	$00		Edition byte
$000D	fcb	$01		Assembler Version
$000E	fdb	$0000		Uninitialized Data Size
$0010	fdb	$0000		Uninitialized DP Data Size
$0012	fdb	$0000		Initialized Data Size
$0014	fdb	$0000		Initialized DP Data Size
$0016	fdb	$0013		Module Code Size
$0018	fdb	$0000		Module Stack size
$001A	fdb	$0000		Module Entry Point
$001C	fcc	"name_a"		Module Name (1 to 9 bytes)
	fcb	$00		NULL String Terminator
</pre>
</td></tr></table>
<br>
<br>
		<b>Global Definitions</b><br>
		<br>
		The global definitions section contains a 2-byte count of global definitions,
		Global Name, null terminator, Flag Type byte, and offset into the code. The
		following format describes one global entry:<br>
		<br>
		<br>
		<b>Global Variable Table:</b><br>
		<br>
		<table class="code" width="500" align="center" ID="Table3"><tr><td class="code">
<pre>
	fdb	$0001	Number of Global entries
	fcc	"_name"	Global Name (1 to 9 bytes)
	fcb	$00	NULL string terminator
	fcb	$04	Type Flag (04 = code)
	fdb	$0000	Offset into code
</pre>
</td></tr></table>
		<br>
		<br>
		<b>The Code Section:</b><br>
		<br>
		<table class="code" width="500" align="center" ID="Table6"><tr><td class="code">
<pre>
_name:	lda	3,s	Get first param off stack
	ldb	#$FF	B is $FF
	ldx	4,s	Get second param off stack
	pshs	y	Store y for future
	ldy	8,s	Get third param off stack
	os9	I$SetStt	Set status
	puls	y	Restore y
	lbra	sysret	Go have system check Carry bit
</pre>
		</td></tr></table>
		<br>
		<br>
		External references are stored as a 2-byte count, followed by that number of
		references. Each reference has a 1-byte flag value indicating the type of
		reference, followed by the 2-byte offset where that reference is found.<br>
		<br>
		<br>
		<b>External Reference Table:</b><br>
		<br>
		<table class="code" width="500" align="center" ID="Table7"><tr><td class="code"><pre>
	fdb	$0002		Number of externals
	fcc	"_sysret"		External Name (1 to 9 bytes)
	fcb	$00		NULL string terminator
	fdb	$0001		Count of this external entry
	fcb	$A0		Type Flag (A0 = code/word/pc)
	fdb	$0011		Offset into code
	fcc	"I$SetStt"	Name of external
	fcb	$00		NULL string terminator
	fdb	$0001		Count of this external entry
	fcb	$28		Type (28 = code/byte)
	fdb	$000D		Offset into code</pre></td></tr></table>
		
		<br>
		<br>
		<br>
		<b>Local Variable Table:</b><br>
		<br>
		<br>
		<table class="code" width="500" align="center" ID="Table8"><tr><td class="code">
<pre>

	fdb		$0000	Number of Local entries
</pre>
</td></tr></table>
		<br>
		<br>
		<b>Common Block Variable Table:</b><br>
		<br>
		<table class="code" width="500" align="center" ID="Table9"><tr><td style="border: 0px">
<pre>

	fdb		$0000	Count of Number

	endsect
</pre>
</td></tr></table>
		<br>
		<br>
		Each reference in the global definitions, external references, or local references
		section is marked by a 1-byte flag value. This value indicates the section the
		reference is located (whether it is a code value, or a pointer from an initialized
		data section), what it refers to (code, initialized DP data, uninitialized DP
		data, initialized data, uninitialized data, or constant), and any other special
		properties of the reference. All such flags are bit-mapped as follows:<br>
		<br>
		<br>				<table align="center" width="500" class="info" ID="Table4">


			<tr><td class="rheader" colspan="3">Modifier flags</td></tr>
			<tr><td>Bit</td><td colspan="2">Description</td></tr>			<tr>				<td rowspan="2">7</td>				<td>0</td><td>Reference is stored as an absolute value.</td>			</tr>			<tr><td>1</td><td>Reference is stored relative to the location of the reference</td></tr>						<tr>				<td rowspan="2">6</td>				<td>0</td><td>Reference value is unmodified</td>			</tr>			<tr><td>1</td><td>Reference is negated</td></tr>						<tr><td class="rheader" colspan="3">Location and Size flags</td></tr>
			<tr><td>Bit</td><td colspan="2">Description</td></tr>						<tr>				<td rowspan="2">5</td>				<td>0</td><td>Reference is in a data section (bit 4 is used)</td>			</tr>			<tr><td>1</td><td>Reference is in the code section (bit 4 is ignored)</td></tr>						<tr>				<td rowspan="2">4</td>				<td>0</td><td></td>			</tr>			<tr><td>1</td><td>Reference is in the direct page</td></tr>									<tr>				<td rowspan="2">3</td>				<td>0</td><td>The size of the reference is 16 bits</td>			</tr>			<tr><td>1</td><td>The size of the reference is 8 byte</td></tr>			
			<tr><td class="rheader" colspan="3">Reference Flags</td></tr>
			<tr><td>Bit</td><td colspan="2">Description</td></tr>						<tr>				<td rowspan="2">2</td>				<td>0</td><td>The reference refers to data</td>			</tr>			<tr><td>1</td><td>The reference refers to code</td></tr>						<tr>				<td rowspan="2">1</td>				<td>0</td><td>The reference refers to non direct-page data</td>			</tr>			<tr><td>1</td><td>The reference refers to direct-page data</td></tr>						<tr>				<td rowspan="2">0</td>				<td>0</td><td>The reference refers to uninitialized data</td>			</tr>			<tr><td>1</td><td>The reference refers to initialized data</td></tr>		</table>					<br>
		<br>
		As a special case, if both bits 1 and 2 are set, the reference is a constant value.
		<br>
		<br>

		<table align="center" width="500" class="info" ID="Table10">


			<tr><td colspan="3" class="rheader">Valid type flags for global references (1)</td></tr>
			<tr><td class="rinfo">Hex Value</td><td class="rinfo">Bit Value</td><td>Description</td></tr>
			<tr><td class="rinfo">04</td><td class="rinfo">00000100</td><td>reference to code</td></tr>
			<tr><td class="rinfo">02</td><td class="rinfo">00000010</td><td>reference to dp bss</td></tr>
			<tr><td class="rinfo">01</td><td class="rinfo">00000001</td><td>reference to non-dp data</td></tr>
			<tr><td class="rinfo">00</td><td class="rinfo">00000000</td><td>reference to non-dp bss</td></tr>

			<tr><td colspan="3" class="rheader">Valid type flags for external references</td></tr>
			<tr><td class="rinfo">Hex Value</td><td class="rinfo">Bit Value</td><td>Description</td></tr>
			<tr><td class="rinfo">a0</td><td class="rinfo">10100000</td><td>reference is in code (word pcr)</td></tr>			<tr><td class="rinfo">20</td><td class="rinfo">00100000</td><td>reference is in code (word)</td></tr>
			<tr><td colspan="3" class="rheader">Valid type flags for local references</td></tr>
			<tr><td class="rinfo">Hex Value</td><td class="rinfo">Bit Value</td><td>Description</td></tr>
			<tr><td class="rinfo">2a</td><td class="rinfo">00101010</td><td>in code/byte - to non-dp bss</td></tr>			<tr><td class="rinfo">22</td><td class="rinfo">00100010</td><td>in code/word - to dp bss</td></tr>			<tr><td class="rinfo">21</td><td class="rinfo">00100001</td><td>in code/word - to non-dp data</td></tr>			<tr><td class="rinfo">20</td><td class="rinfo">00100000</td><td>in code/word - to non-dp bss</td></tr>			<tr><td class="rinfo">04</td><td class="rinfo">00000100</td><td>in non-dp data/word - to code</td></tr>			<tr><td class="rinfo">02</td><td class="rinfo">00000001</td><td>in non-dp data/word - to non-dp data</td></tr>			<tr><td class="rinfo">00</td><td class="rinfo">00000000</td><td>in non-dp data/word - to non-dp bss</td></tr>		</table>
		<br>
		<br>
	</tr></td>
</table>
</div>
<br>
<br>
<br>
<br>
